# 学习笔记 (Week 1)

## 第三课：数组、链表、跳表
- 数组
  - 内存中一块连续的地址（读取速度快的原因，不需重新寻址）
  - 存储相同类型的数据
  - 容量不可变，扩容需要重新申请存储空间，然后将原来的数据拷贝到新数组的相对位置。（一般规则是扩容两倍）
  - 在位置 i 处删除或插入元素，需要移动 i 后面所有元素。（增删速度慢的原因）
- 链表
  - 链表的元素中包含指向临近元素的指针（一个为单向，两个为双向）
  - 查询元素只能从头部开始遍历，直到目标位置。（读取速度慢的原因）
  - 插入和删除元素时，只需要修改目标节点的前节点的索引即可。（增删速度快的原因）
  - 链表的元素在内存中不是连续的，没有容量的概念
  - 当链表尾部节点指向前置节点的时候，该链表有环。
- 跳表
  - 诞生于 1989 年
  - 跳表是链表的升维结构，在原始的链表上新增 K 个层级的索引，类似二分法
  - 维护成本较高，每次修改元素都要修改每个层级的索引
  - 只能用于链表元素有序的情况下
  - 对标的是二叉搜索树中的平衡树和二分查找
  - 插入、删除、搜索都是 O(log n) 的数据结构
  - 原理简单、容易实现、方便扩展、效率更高，使用于 Redis、LevelDB 中


## 第四课：栈、队列、优先队列、双端队列
- 栈
  - LIFO(Last In First Out) 后进先出的操作顺序
  - 单调栈：栈内元素是递增或递减的有序排列
  - 可视为一种特殊的队列，尾部添加，尾部提取
- 队列
  - FIFO(First In First Out) 先进先出的操作顺序
  - 头部提取，尾部追加
  - 底层实现可以有很多中实现方式，基于数组或者基于链表等
- 优先队列
  - 插入操作 O(1)
  - 去除操作 O(log n) 按照元素的优先级顺序读取
  - 底层实现方式较为多样，如：Heap bst treap 等
- 双端队列
  - 两端都可以提取、插入操作的队列

## 总结
本周学习了基本常用的数据结构，每种结构都有其特殊的操作方式，主要的偏向是读、写速度。掌握了这些数据结构后，可以游刃有余的维护数据，方便在特殊应用场景中使用。是写出高性能代码的基本功。